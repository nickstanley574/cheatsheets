# [MODSECURITY 3.0 & NGINX: Quick Start Guide](https://www.nginx.com/resources/library/modsecurity-3-nginx-quick-start-guide)
### by Faisal Memon, Owen Garrett, and Michael Pleshakov

## Preface 

ModSecurity is an open source web application firewall (WAF) ModSecurity protects applications against a broad range of Layer 7 attacks, such as SQL injection (SQLi), local file inclusion (LFI), and cross-site scripting (XSS) These three attack vectors together accounted for 95% of known Layer 7 attacks in Q1 2017, according to the report, Akamai State of the Internet – Security The report also states that the purpose of attacks varies, but the majority are aimed at stealing data. 

## 1 Introduction 

### How ModSecurity Works

- When an HTTP request is made, ModSecurity inspects all parts of the request for any malicious content or anomalies If the request is deemed malicious it can be blocked, logged, or both, depending on configuration. 
- ModSecurity uses a database of “rules” that define malicious behaviors

### ModSecurity 3.0’s New Architecture

Previous versions of ModSecurity, up through version 2 9, did technically work with NGINX, but suffered from poor performance This is because ModSecurity was wrapped inside a full version of Apache HTTP Server, which provided a compatibility layer. ModSecurity 3 0, however, is a complete rewrite of ModSecurity that works natively with NGINX without requiring Apache. 

The NGINX Plus distribution includes the compiled dynamic module NGINX Open Source users have to compile the ModSecurity source code each time they change NGINX versions.

## 2 Installing ModSecurity

#### NGINX Open Source Installation Instructions

1 - Install NGINX from Our Official Repository
2 - Install Prerequisite Packages
3 - Download and Compile libmodsecurity
4 - Download the NGINX Connector for ModSecurity and Compile it as a Dynamic Module
5 - Load the NGINX ModSecurity Connector Dynamic Module

#### NGINX Plus Installation Instructions

1. Use the OS package-management utility to install the dynamic module from the NGINX Plus module repository 

Documentation for modsecurity directives in the NGINX configuration file is available on GitHub at: github com/SpiderLabs/ModSecurity-nginx#usage

## 3 Installing the OWASP Core Rule Set 

The CRS is community-maintained and contains rules to help stop common attack vectors, including SQL injection (SQLi), cross- site scripting (XSS), and many others. The CRS is a generic blacklist rule set consisting of snippets that are known to be used in attacks The snippets are combined together to form the rule set. 

### CRS File and Directory Structure

The CRS is hosted in GitHub at: github com/SpiderLabs/owasp-modsecurity-crs

`crs-setup.conf.example` – The main configuration file for the CRS It defines the anomaly scoring thresholds, paranoia levels, and other key ModSecurity configurables. 

`rules/` – Directory containing the rules organized into different files, each of which has a number assigned to it:

The CRS uses a configurable anomaly-scoring model Each rule that fires increases the anomaly score and if the score exceeds the configured anomaly threshold then the transaction is blocked The anomaly levels are as follows: 
`90x` files – Exclusions to remedy false positives
`91x` files – Rules to detect malicious clients, such as scanners and bots
`92x` files – Rules to detect protocol violations
`93x` and 94x files – Rules to detect application attacks such as SQLi and Remote Command Execution
`95x` files – Rules to detect outbound data leakage These are not supported by NGINX or NGINX Plus
`.data` files – Data used by the rules. For example crawlers-user- agents.data contains a list of User-Agent values used by scanners. This file is used by rule REQUEST-913-SCANNER-DETECTION.conf to identify scanners and bots.

**Critical** – Anomaly score of **5** Indicates a likely application attack Mostly generated by `93x` and `94x` files

**Error** – Anomaly score of **4**Indicates likely data leakage Generated mostly by `95x` files `95x` files are not supported with NGINX or NGINX Plus

**Warning** – Anomaly score of **3** Indicates likely malicious client Generated mostly by `91x` files

**Notice** – Anomaly score of **2** Indicates likely protocol violations Generated mostly by `92x` files

By default the CRS blocks all inbound traffic with an anomaly score of **5** or higher This means any critical rule that fires causes the transaction to be dropped Three or more Notice-level violations also lead to the transaction being blocked. 

## 4 Installing the Trustwave SpiderLabs Commercial Rule Set 

You must purchase the Trustwave SpiderLabs Rules directly from Trustwave

## 5 Enabling Project Honeypot 

Project Honeypot maintains a list of known malicious IP addresses, available free to the public ModSecurity integrates with Project Honeypot and can automatically block IP addresses on the Project Honeypot list This process is known as IP reputation.

###  How Project Honeypot Works

Project Honeypot is a community-driven online database of IP addresses that are suspected spammers or bots Each IP address is assigned a threat score between 0 and 255; the higher the number, the more likely the IP address is to be malicious. Project Honeypot lookups are done in real time when an HTTP request is received, so enabling this functionality it likely to worsen performance. 

### Set Up Your Honeypot

1. Sign up a for a free Project Honeypot account (projecthoneypot org/create_account php)
2. Set up your honeypot – Project Honeypot offers the honeypot script in PHP, Python, ASP, and a few other languages (projecthoneypot org/manage_honey_pots.php)
3. Download the honeypot script

## 6 Logging

### Audit Log 

An audit log For every transaction that’s blocked, ModSecurity provides detailed logs about the transaction and why it was blocked.

The audit log is useful for learning not just why an individual attack was blocked, but for finding out more about overall attack patterns. ModSecurity will log all transactions that triggered a warning or error, as well as all transactions that resulted in 5xx and 4xx responses, except for 404 Audit Logging Configuration.

#### The ModSecurity audit log is partitioned into sections

| Section | Description                                                     |
|---------|-----------------------------------------------------------------|
| A       |	Audit log header (mandatory)                                    |
| B       |	Request headers                                                 |
| C       |	Request body                                                    |
| D       |	Reserved                                                        |
| E	      | Response body                                                   |
| F	      | Response headers                                                |
| G	      | Reserved                                                        |
| H	      | Audit log trailer, which contains additional data               |
| I	      | Compact request body alternative (to part C)                    |
| J	      | Information on uploaded                                         |
| K	      | Contains a list of all rules that matched for the transaction   |
| Z	      | Final boundary (mandatory)                                      |

`SecAuditEngine` - Controls what should be logged
* `Off` – Disable the audit log
* `On` – Log all transactions, which can be useful when debugging
* `RelevantOnly` – Log only transactions that have triggered a warning/error, or have a status code that matches what’s in the SecAuditLogRelevantStatus directive. 

`SecAuditLogRelevantStatus` - If `SecAuditEngine` is set to `RelevantOnly`, then this directive controls what HTTP response status codes should be logged It’s **regular expression-based** The above value will log all `5xx` and `4xx` responses, excluding `404`s

`SecAuditLogParts` – Controls what sections should be included in the access log Removing sections you’re not interested in reduces the size of the audit log and make it easier to scan. (`ABCDEFGHIJKZ`)

### Debug Log 

A debug log When turned on, this log keeps extensive information about everything that ModSecurity does. For troubleshooting issues as to why something is not working the way you expect it to, the debug log is your go-to resource. 

The debug log lists the rule ID number for easy searching. By default, the debug log is *disabled*, as it can negatively affect performance Just as with audit logging, the debug log is configured in `/etc/nginx/modsec/modsecurity.conf`. 

`SecDebugLog` – Specifies the path to the debug log file.

`SecDebugLogLevel` – 0–9 indicates how much information to log, with 9 being the most If you’re troubleshooting, setting this value to 9 is the most helpful. 

## 7 Implementing ModSecurity in Production. 

### Tuning to Minimize False Positives
The basic idea is to run ModSecurity in blocking mode, increase the anomaly threshold to a very high value, and then progressively lower it. 

1. Ensure ModSecurity is in active blocking mode. 
2. Ensure the audit log is enabled (which it is by default).
3. Increase the anomaly threshold to 1000 This is done by uncommenting this rule in `crs-setup.conf` and modifying the anomaly thresholds.
4. Monitor the audit log for false positives, and prevent them by adding `SecRemoveRuleByID` to `main.conf`.
5. If you don't see any false positives after running for some time, lower the anomaly threshold by half and repeat steps 4 and 5 Continue this process until the anomaly threshold is back to 5, the default value. 

### Disabling the Audit Log

1. Audit logging negatively affects ModSecurity performance.
2. The log file can grow large very quickly and exhaust disk space.

To disable audit logging, change the value of the `SecAuditEngine` directive in `modsecurity.conf` to `off`. The NGINX error log, enabled by default, logs all blocked transactions so you don't lose information by disabling the ModSecurity audit log. 

### Not Inspecting Static Content
There is little point running ModSecurity rules against requests handled by a simple static-content virtual server or by a web server with no dynamic applications Instead, use the location directive to route request requests for static and dynamic resources to different servers or filesystem locations. 

### Using NGINX for DDoS Mitigation and Rate Limiting
The ModSecurity dynamic module doesn’t currently support the built-in CRS rule for DDoS mitigation (`REQUEST-912-DOS-PROTECTION.conf`). Fortunately, NGINX and NGINX Plus provide built-in rate limiting and DDoS mitigation themselves. The `limit_req_zone` directive defines the parameters for rate limiting, while `limit_req` enables rate limiting within the context where it appears.

### Other Production-Readiness Tips

* Be prepared to scale up or scale out – Monitor CPU utilization by the NGINX worker processes If it consistently exceeds 50%, consider scaling up (enabling more cores and running more NGINX worker processes) or out (deploying more NGINX servers and load balancing traffic across them). 
* Select your ModSecurity rules carefully –  **do not enable rules needlessly** – it increases CPU utilization, and might affect latency or generate false-positive matches. 
* Add a caching layer – An alternative to splitting out content as described in section Not Inspecting Static Content is to add a caching layer in front of servers running NGINX with ModSecurity. 
* Keep on top of the latest security vulnerabilities – ModSecurity is a great tool for protecting web applications and can stop a broad range of attacks, but it is no replacement for proactive monitoring of security vulnerabilities

